/*
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var a in n)("object"==typeof exports?exports:e)[a]=n[a]}}(this,function(){return function(e){function t(a){if(n[a])return n[a].exports;var r=n[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,a){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:a})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=2)}([function(e,t,n){e.exports="#define GLSLIFY 1\n"+n(8)+"\n"+n(9)+"\n\n\nfloat scene( in vec3 pos )\n{\n  // //Coffee Table\n  // float result = Box( pos - vec3( 0, 0.45, 0 ), vec3( 1.18, 0.45, 0.78 ) );\n  // result = Difference( result, Box( pos - vec3( 0, 0.45 - 0.15, 0 ), vec3( 1.2, 0.45, 0.78 - 0.15 ) ) );\n  // result = Difference( result, Box( pos - vec3( 0, 0.45 - 0.15, 0 ), vec3( 1.18 - 0.15, 0.45, 0.9 ) ) );\n  //Floor\n  float result = 1000.0;\n  result = Union( result, Box( pos + vec3( 0.0, 0.125, 0.0 ), vec3( 5.0, 0.125, 5.0 ) ) );\n  //Left Wall\n  result = Union( Plane( pos, vec3( 1.0, 0.0, 0.0 ), 4.75 ), result );\n  //Right Wall\n  result = Union( Plane( pos, vec3( 0.0, 0.0, 1.0 ), 4.75 ), result );\n  //Bounding Box\n  result = Intersection( result, Box( pos - vec3( 0.0, 3.0 - 0.125, 0.0 ), vec3( 5.0, 3.125, 5.0 ) ) );\n  //Left Window\n  result = Difference( result, Box( pos + vec3( 5.0, -3.0, 0.0 ), vec3( 0.5, 2.0, 1.5 ) ) );\n  //Back Window\n  result = Difference( result, Box( pos + vec3( 0.0, -3.0, 5.0 ), vec3( 1.5, 2.0, 0.5 ) ) );\n  // result = Union( result, Plane( pos, vec3( 0.0, 1.0, 0.0 ), 0.0 ) );\n  return result;\n}\n"},function(e,t){e.exports="#define GLSLIFY 1\n#define cGammaCorrection vec3( 0.4545454545 )\n\nuniform float iAspect;\nuniform mat4 iCameraViewMatrix;\nuniform vec3 iCameraEyePoint;\nuniform float iCameraFov;\nuniform float iDevicePixelRatio;\n\nvec3 gamma( in vec3 color )\n{\n  return pow( color, cGammaCorrection );\n}\n\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        scene(pos+eps.xyy) - scene(pos-eps.xyy),\n        scene(pos+eps.yxy) - scene(pos-eps.yxy),\n        scene(pos+eps.yyx) - scene(pos-eps.yyx) );\n    return normalize(nor);\n}\n\nfloat castRay( in vec3 ro, in vec3 rd ) {\n    float maxd = 150.0; // ray marching distance max\n    float s = maxd;\n    float d = 0.0;\n    for( int i = 0; i < 150; i++ ) {\n        if( s < 0.0001 ||  s > maxd ) break;\n        s = scene( ro + rd * d );\n        d += s * 0.25;\n    }\n    return d;\n}\n\nvec4 render( in vec3 ro, in vec3 rd ) {\n  float t = castRay( ro, rd );\n  vec3 pos = ro + t * rd;\n  float mixvalue = clamp( 100.0 - t, 0.0, 1.0 );\n  vec3 normal = mat3(iCameraViewMatrix) * calcNormal( pos );\n  float diffuse = clamp( dot( vec3( 0, 0, 1 ), normal ), 0.0, 1.0 );\n  float distance = 1.0 - ( Plane( pos, vec3( -1.0 ), 15.0 ) / 30.0 );\n  vec3 color = mix( vec3( 0.125 ), vec3( distance ), t < 50.0 ? 1.0 : 0.0 );\n  pos = vec3( mod( pos, 0.25 ) - 0.125 );\n  pos *= 4.0;\n  return vec4( gamma( color ) + diffuse * 0.125 * distance + 0.25 * pow( length( pos ), 8.0 ), 1.0 );\n}\n\nvec4 render( in vec2 tc ) {\n  vec2 q = tc;\n  vec2 p = 2.0 * q - 1.0;\n  p.x *= iAspect;\n\n  vec3 ro = iCameraEyePoint;\n  vec3 rd = normalize( vec3( p.xy, - tan( 2.5 * iCameraFov ) ) ) * mat3(iCameraViewMatrix);\n  rd *= iDevicePixelRatio;\n  ro *= iDevicePixelRatio;\n  vec4 col = render( ro, rd );\n  return col;\n}\n"},function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}var r=a(n(3));a(n(12));navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(android)|(webOS)/i)&&navigator.getVRDisplays||(THREE.ARView=r.default)},function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var r=a(n(4)),o=a(n(5)),i=a(n(6)),s=a(n(7)),l=a(n(10));THREE.OrbitControls=o.default;t.default=function e(t,n){var a=this;!function(t,n){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this),this.setupDisplay=function(){a.vrDisplay.getPose=function(){return this.vrDisplay.pose_.position[0]=this.camera.position.x,this.vrDisplay.pose_.position[1]=this.camera.position.y,this.vrDisplay.pose_.position[2]=this.camera.position.z,this.vrDisplay.pose_.orientation[0]=this.camera.quaternion.x,this.vrDisplay.pose_.orientation[1]=this.camera.quaternion.y,this.vrDisplay.pose_.orientation[2]=this.camera.quaternion.z,this.vrDisplay.pose_.orientation[3]=this.camera.quaternion.w,this.vrDisplay.pose_}.bind(a),a.vrDisplay.getFrameData=function(e){e.timestamp=performance.now(),e.pose=this.vrDisplay.getPose(),this.camera.projectionMatrix.toArray(this.vrDisplay.projectionMatrix_),e.leftProjectionMatrix=e.rightProjectionMatrix=this.vrDisplay.projectionMatrix_,e.leftViewMatrix=e.rightViewMatrix=this.camera.matrixWorldInverse}.bind(a),a.vrDisplay.hitTest=function(e,t){this.mouse.set(2*e-1,2*-t+1),this.raycaster.setFromCamera(this.mouse,this.camera);var n=this.resultsVariable.material.uniforms;n.vUv.value.set(e,1-t),this._setUniforms(n),this.gpuCompute.compute();var a=this.renderer.context,r=new Uint8Array(16);a.readPixels(0,0,2,2,a.RGBA,a.UNSIGNED_BYTE,r);var o=(r=new Float32Array(r.buffer))[3],i=this.raycaster.ray.at(o);return this.normal.set(r[0],r[1],r[2]),this.position.set(i.x,i.y,i.z),this.center.set(i.x,i.y,i.z),this.center.add(this.normal),this.hitMatrix.lookAt(this.position,this.center,this.up),this.hitMatrix.setPosition(this.position),this.hitMatrix.toArray(this.hit.modelMatrix),[this.hit]}.bind(a)},this.setupScene=function(){a.camera=new THREE.PerspectiveCamera(30,window.innerWidth/window.innerHeight,.1,1e3),a.camera.position.set(2.5,1.6,2.5),a.scene=new THREE.Scene},this.setupRayCaster=function(){a.raycaster=new THREE.Raycaster,a.mouse=new THREE.Vector2(0,0)},this.setupGPUCompute=function(){a.gpuCompute=new r.default(2,2,a.renderer),a.resultsVariable=a.gpuCompute.addVariable("result",l.default);var e=a.resultsVariable.material.uniforms;e.vUv={value:new THREE.Vector2(1,1)},e.iAspect={value:1.5107913669},e.iCameraEyePoint={value:new THREE.Vector3(0,0,1)},e.iCameraFov={value:1.5107913669},e.iCameraViewMatrix={value:new THREE.Matrix4},e.iDevicePixelRatio={value:a.renderer.getPixelRatio()},a.resultsVariable.material.defines.BOUNDS=2..toFixed(1);var t=a.gpuCompute.init();null!==t&&console.error(t)},this.setupRoom=function(){(new THREE.OBJLoader).load("models/room.obj",function(e){if(e.children){var t=e.children[0];t.scale.set(5,5,5),t.material=new THREE.MeshNormalMaterial,this.scene.add(t)}}.bind(a))},this.setupMarcher=function(){a.orthoCamera=new THREE.OrthographicCamera(-1,1,1,-1,-1,1),a.orthoScene=new THREE.Scene,a.marcher=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),new THREE.RawShaderMaterial({uniforms:{iAspect:{value:1.5107913669},iCameraEyePoint:{value:new THREE.Vector3},iCameraFov:{value:0},iCameraViewMatrix:{value:new THREE.Matrix4},iDevicePixelRatio:{value:1}},vertexShader:i.default,fragmentShader:s.default,side:THREE.DoubleSide,transparent:!0})),a.orthoScene.add(a.marcher)},this.setupControls=function(){a.controls=new THREE.OrbitControls(a.camera,a.renderer.domElement)},this.update=function(){a.controls.update();var e=a.renderer.getSize();a.camera.aspect=e.width/e.height,a.camera.updateProjectionMatrix(),a._setUniforms(a.marcher.material.uniforms)},this._render=function(){a.camera.updateMatrixWorld(!0),a.renderer.render(a.orthoScene,a.orthoCamera),a.renderer.clearDepth(),a.renderer.render(a.scene,a.camera)},this.render=function(){a.update(),a._render()},this._setUniforms=function(e){e.iAspect.value=a.camera.aspect,e.iCameraEyePoint.value=a.camera.position,e.iCameraFov.value=THREE.Math.degToRad(a.camera.fov),e.iCameraViewMatrix.value=a.camera.matrixWorldInverse,e.iDevicePixelRatio.value=a.renderer.getPixelRatio()},this.vrDisplay=t,this.renderer=n,this.camera,this.scene,this.controls,this.orthoCamera,this.orthoScene,this.raycaster,this.mouse,this.gpuCompute,this.resultsVariable,this.hitMatrix=new THREE.Matrix4,this.up=new THREE.Vector3(0,1,0),this.normal=new THREE.Vector3,this.center=new THREE.Vector3,this.position=new THREE.Vector3,this.hit=new VRHit,this.setupScene(),this.setupRayCaster(),this.setupGPUCompute(),this.setupDisplay(),this.setupMarcher(),this.setupControls()}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,n){function a(n){n.defines.resolution="vec2( "+e.toFixed(1)+", "+t.toFixed(1)+" )"}function r(e,t){t=t||{};var n=new THREE.ShaderMaterial({uniforms:t,vertexShader:"void main()  {\n\n gl_Position = vec4( position, 1.0 );\n\n}\n",fragmentShader:e});return a(n),n}this.variables=[],this.currentTextureIndex=0;var o=new THREE.Scene,i=new THREE.Camera;i.position.z=1;var s={texture:{value:null}},l=r("uniform sampler2D texture;\n\nvoid main() {\n\n vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n gl_FragColor = texture2D( texture, uv );\n\n}\n",s),c=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),l);o.add(c),this.addVariable=function(e,t,n){var a={name:e,initialValueTexture:n,material:this.createShaderMaterial(t),dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};return this.variables.push(a),a},this.setVariableDependencies=function(e,t){e.dependencies=t},this.init=function(){if(!n.extensions.get("OES_texture_float"))return"No OES_texture_float support for float textures.";if(0===n.capabilities.maxVertexTextures)return"No support for vertex shader textures.";for(var a=0;a<this.variables.length;a++){var r=this.variables[a];r.renderTargets[0]=this.createRenderTarget(e,t,r.wrapS,r.wrapT,r.minFilter,r.magFilter),r.renderTargets[1]=this.createRenderTarget(e,t,r.wrapS,r.wrapT,r.minFilter,r.magFilter),this.renderTexture(r.initialValueTexture,r.renderTargets[0]),this.renderTexture(r.initialValueTexture,r.renderTargets[1]);var o=r.material,i=o.uniforms;if(null!==r.dependencies)for(var s=0;s<r.dependencies.length;s++){var l=r.dependencies[s];if(l.name!==r.name){for(var c=!1,u=0;u<this.variables.length;u++)if(l.name===this.variables[u].name){c=!0;break}if(!c)return"Variable dependency not found. Variable="+r.name+", dependency="+l.name}i[l.name]={value:null},o.fragmentShader="\nuniform sampler2D "+l.name+";\n"+o.fragmentShader}}return this.currentTextureIndex=0,null},this.compute=function(){for(var e=this.currentTextureIndex,t=0===this.currentTextureIndex?1:0,n=0,a=this.variables.length;n<a;n++){var r=this.variables[n];if(null!==r.dependencies)for(var o=r.material.uniforms,i=0,s=r.dependencies.length;i<s;i++){var l=r.dependencies[i];o[l.name].value=l.renderTargets[e].texture}this.doRenderTarget(r.material,r.renderTargets[t])}this.currentTextureIndex=t},this.getCurrentRenderTarget=function(e){return e.renderTargets[this.currentTextureIndex]},this.getAlternateRenderTarget=function(e){return e.renderTargets[0===this.currentTextureIndex?1:0]},this.addResolutionDefine=a,this.createShaderMaterial=r,this.createRenderTarget=function(n,a,r,o,i,s){return n=n||e,a=a||t,r=r||THREE.ClampToEdgeWrapping,o=o||THREE.ClampToEdgeWrapping,i=i||THREE.NearestFilter,s=s||THREE.NearestFilter,new THREE.WebGLRenderTarget(n,a,{wrapS:r,wrapT:o,minFilter:i,magFilter:s,format:THREE.RGBAFormat,type:/(iPad|iPhone|iPod)/g.test(navigator.userAgent)?THREE.HalfFloatType:navigator.userAgent.toLowerCase().indexOf("firefox")>-1?void 0:THREE.FloatType,stencilBuffer:!1})},this.createTexture=function(n,a){n=n||e,a=a||t;var r=new Float32Array(n*a*4),o=new THREE.DataTexture(r,e,t,THREE.RGBAFormat,THREE.FloatType);return o.needsUpdate=!0,o},this.renderTexture=function(e,t){s.texture.value=e,this.doRenderTarget(l,t),s.texture.value=null},this.doRenderTarget=function(e,t){c.material=e,n.render(o,i,t),c.material=l}}},function(e,t,n){"use strict";function a(e,t){function n(){return Math.pow(.95,v.zoomSpeed)}function a(e){T.theta-=e}function r(e){T.phi-=e}function o(e){v.object instanceof THREE.PerspectiveCamera?R/=e:v.object instanceof THREE.OrthographicCamera?(v.object.zoom=Math.max(v.minZoom,Math.min(v.maxZoom,v.object.zoom*e)),v.object.updateProjectionMatrix(),_=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),v.enableZoom=!1)}function i(e){v.object instanceof THREE.PerspectiveCamera?R*=e:v.object instanceof THREE.OrthographicCamera?(v.object.zoom=Math.max(v.minZoom,Math.min(v.maxZoom,v.object.zoom/e)),v.object.updateProjectionMatrix(),_=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),v.enableZoom=!1)}function s(e){if(!1!==v.enabled){switch(e.preventDefault(),e.button){case v.mouseButtons.ORBIT:if(!1===v.enableRotate)return;!function(e){M.set(e.clientX,e.clientY)}(e),g=P.ROTATE;break;case v.mouseButtons.ZOOM:if(!1===v.enableZoom)return;!function(e){F.set(e.clientX,e.clientY)}(e),g=P.DOLLY;break;case v.mouseButtons.PAN:if(!1===v.enablePan)return;!function(e){D.set(e.clientX,e.clientY)}(e),g=P.PAN}g!==P.NONE&&(document.addEventListener("mousemove",l,!1),document.addEventListener("mouseup",c,!1),v.dispatchEvent(b))}}function l(e){if(!1!==v.enabled)switch(e.preventDefault(),g){case P.ROTATE:if(!1===v.enableRotate)return;!function(e){C.set(e.clientX,e.clientY),O.subVectors(C,M);var t=v.domElement===document?v.domElement.body:v.domElement;a(2*Math.PI*O.x/t.clientWidth*v.rotateSpeed),r(2*Math.PI*O.y/t.clientHeight*v.rotateSpeed),M.copy(C),v.update()}(e);break;case P.DOLLY:if(!1===v.enableZoom)return;!function(e){A.set(e.clientX,e.clientY),V.subVectors(A,F),V.y>0?o(n()):V.y<0&&i(n()),F.copy(A),v.update()}(e);break;case P.PAN:if(!1===v.enablePan)return;!function(e){I.set(e.clientX,e.clientY),z.subVectors(I,D),N(z.x,z.y),D.copy(I),v.update()}(e)}}function c(e){!1!==v.enabled&&(document.removeEventListener("mousemove",l,!1),document.removeEventListener("mouseup",c,!1),v.dispatchEvent(E),g=P.NONE)}function u(e){!1===v.enabled||!1===v.enableZoom||g!==P.NONE&&g!==P.ROTATE||(e.preventDefault(),e.stopPropagation(),function(e){e.deltaY<0?i(n()):e.deltaY>0&&o(n()),v.update()}(e),v.dispatchEvent(b),v.dispatchEvent(E))}function m(e){!1!==v.enabled&&!1!==v.enableKeys&&!1!==v.enablePan&&function(e){switch(e.keyCode){case v.keys.UP:N(0,v.keyPanSpeed),v.update();break;case v.keys.BOTTOM:N(0,-v.keyPanSpeed),v.update();break;case v.keys.LEFT:N(v.keyPanSpeed,0),v.update();break;case v.keys.RIGHT:N(-v.keyPanSpeed,0),v.update()}}(e)}function p(e){if(!1!==v.enabled){switch(e.touches.length){case 1:if(!1===v.enableRotate)return;!function(e){M.set(e.touches[0].pageX,e.touches[0].pageY)}(e),g=P.TOUCH_ROTATE;break;case 2:if(!1===v.enableZoom)return;!function(e){var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,a=Math.sqrt(t*t+n*n);F.set(0,a)}(e),g=P.TOUCH_DOLLY;break;case 3:if(!1===v.enablePan)return;!function(e){D.set(e.touches[0].pageX,e.touches[0].pageY)}(e),g=P.TOUCH_PAN;break;default:g=P.NONE}g!==P.NONE&&v.dispatchEvent(b)}}function h(e){if(!1!==v.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:if(!1===v.enableRotate)return;if(g!==P.TOUCH_ROTATE)return;!function(e){C.set(e.touches[0].pageX,e.touches[0].pageY),O.subVectors(C,M);var t=v.domElement===document?v.domElement.body:v.domElement;a(2*Math.PI*O.x/t.clientWidth*v.rotateSpeed),r(2*Math.PI*O.y/t.clientHeight*v.rotateSpeed),M.copy(C),v.update()}(e);break;case 2:if(!1===v.enableZoom)return;if(g!==P.TOUCH_DOLLY)return;!function(e){var t=e.touches[0].pageX-e.touches[1].pageX,a=e.touches[0].pageY-e.touches[1].pageY,r=Math.sqrt(t*t+a*a);A.set(0,r),V.subVectors(A,F),V.y>0?i(n()):V.y<0&&o(n()),F.copy(A),v.update()}(e);break;case 3:if(!1===v.enablePan)return;if(g!==P.TOUCH_PAN)return;!function(e){I.set(e.touches[0].pageX,e.touches[0].pageY),z.subVectors(I,D),N(z.x,z.y),D.copy(I),v.update()}(e);break;default:g=P.NONE}}function f(e){!1!==v.enabled&&(v.dispatchEvent(E),g=P.NONE)}function d(e){!1!==v.enabled&&e.preventDefault()}this.object=e,this.domElement=void 0!==t?t:document,this.enabled=!0,this.target=new THREE.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:THREE.MOUSE.LEFT,ZOOM:THREE.MOUSE.MIDDLE,PAN:THREE.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return w.phi},this.getAzimuthalAngle=function(){return w.theta},this.saveState=function(){v.target0.copy(v.target),v.position0.copy(v.object.position),v.zoom0=v.object.zoom},this.reset=function(){v.target.copy(v.target0),v.object.position.copy(v.position0),v.object.zoom=v.zoom0,v.object.updateProjectionMatrix(),v.dispatchEvent(x),v.update(),g=P.NONE},this.update=function(){var t=new THREE.Vector3,n=(new THREE.Quaternion).setFromUnitVectors(e.up,new THREE.Vector3(0,1,0)),r=n.clone().inverse(),o=new THREE.Vector3,i=new THREE.Quaternion;return function(){var e=v.object.position;return t.copy(e).sub(v.target),t.applyQuaternion(n),w.setFromVector3(t),v.autoRotate&&g===P.NONE&&a(2*Math.PI/60/60*v.autoRotateSpeed),w.theta+=T.theta,w.phi+=T.phi,w.theta=Math.max(v.minAzimuthAngle,Math.min(v.maxAzimuthAngle,w.theta)),w.phi=Math.max(v.minPolarAngle,Math.min(v.maxPolarAngle,w.phi)),w.makeSafe(),w.radius*=R,w.radius=Math.max(v.minDistance,Math.min(v.maxDistance,w.radius)),v.target.add(H),t.setFromSpherical(w),t.applyQuaternion(r),e.copy(v.target).add(t),v.object.lookAt(v.target),!0===v.enableDamping?(T.theta*=1-v.dampingFactor,T.phi*=1-v.dampingFactor):T.set(0,0,0),R=1,H.set(0,0,0),!!(_||o.distanceToSquared(v.object.position)>y||8*(1-i.dot(v.object.quaternion))>y)&&(v.dispatchEvent(x),o.copy(v.object.position),i.copy(v.object.quaternion),_=!1,!0)}}(),this.dispose=function(){v.domElement.removeEventListener("contextmenu",d,!1),v.domElement.removeEventListener("mousedown",s,!1),v.domElement.removeEventListener("wheel",u,!1),v.domElement.removeEventListener("touchstart",p,!1),v.domElement.removeEventListener("touchend",f,!1),v.domElement.removeEventListener("touchmove",h,!1),document.removeEventListener("mousemove",l,!1),document.removeEventListener("mouseup",c,!1),window.removeEventListener("keydown",m,!1)};var v=this,x={type:"change"},b={type:"start"},E={type:"end"},P={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},g=P.NONE,y=1e-6,w=new THREE.Spherical,T=new THREE.Spherical,R=1,H=new THREE.Vector3,_=!1,M=new THREE.Vector2,C=new THREE.Vector2,O=new THREE.Vector2,D=new THREE.Vector2,I=new THREE.Vector2,z=new THREE.Vector2,F=new THREE.Vector2,A=new THREE.Vector2,V=new THREE.Vector2,S=function(){var e=new THREE.Vector3;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),H.add(e)}}(),j=function(){var e=new THREE.Vector3;return function(t,n){e.setFromMatrixColumn(n,1),e.multiplyScalar(t),H.add(e)}}(),N=function(){var e=new THREE.Vector3;return function(t,n){var a=v.domElement===document?v.domElement.body:v.domElement;if(v.object instanceof THREE.PerspectiveCamera){var r=v.object.position;e.copy(r).sub(v.target);var o=e.length();o*=Math.tan(v.object.fov/2*Math.PI/180),S(2*t*o/a.clientHeight,v.object.matrix),j(2*n*o/a.clientHeight,v.object.matrix)}else v.object instanceof THREE.OrthographicCamera?(S(t*(v.object.right-v.object.left)/v.object.zoom/a.clientWidth,v.object.matrix),j(n*(v.object.top-v.object.bottom)/v.object.zoom/a.clientHeight,v.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),v.enablePan=!1)}}();v.domElement.addEventListener("contextmenu",d,!1),v.domElement.addEventListener("mousedown",s,!1),v.domElement.addEventListener("wheel",u,!1),v.domElement.addEventListener("touchstart",p,!1),v.domElement.addEventListener("touchend",f,!1),v.domElement.addEventListener("touchmove",h,!1),window.addEventListener("keydown",m,!1),this.update()}Object.defineProperty(t,"__esModule",{value:!0}),(a.prototype=Object.create(THREE.EventDispatcher.prototype)).constructor=a,Object.defineProperties(a.prototype,{center:{get:function(){return console.warn("OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(e){console.warn("OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!e}},noRotate:{get:function(){return console.warn("OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(e){console.warn("OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!e}},noPan:{get:function(){return console.warn("OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(e){console.warn("OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!e}},noKeys:{get:function(){return console.warn("OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(e){console.warn("OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!e}},staticMoving:{get:function(){return console.warn("OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(e){console.warn("OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!e}},dynamicDampingFactor:{get:function(){return console.warn("OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(e){console.warn("OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=e}}}),t.default=a},function(e,t){e.exports="precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},function(e,t,n){e.exports="precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\n"+n(0)+"\n"+n(1)+"\n\nvarying vec2 vUv;\n\nvoid main() {\n  gl_FragColor = render( vUv );\n}\n"},function(e,t){e.exports="#define GLSLIFY 1\n#ifndef PHI_P\n#define PHI_P 0.5*(1.0+sqrt(5.0))\n#endif\n\n#ifndef PHI_N\n#define PHI_N 0.5*(1.0-sqrt(5.0))\n#endif\n\n//2D SHAPES\nfloat Line( vec3 pos, vec3 a, vec3 b ) {\n  vec3 pa = pos - a;\n  vec3 ba = b - a;\n  float t = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0);\n  vec3 pt = a + t * ba;\n  return length( pt - pos );\n}\n\nfloat Circle( vec2 pos, float radius ) {\n  return length( pos ) - radius;\n}\n\nfloat Square( vec2 pos, vec2 size ) {\n  vec2 v = abs( pos ) - size;\n  return max( v.x, v.y );\n}\n\n//3D SHAPES\nfloat Plane( vec3 pos, vec3 normal, float offset ) {\n  return dot( pos, normal ) + offset;\n}\n\nfloat Cone( vec3 pos, float radius, float height ) {\n  float z = ( height * 0.5 ) - pos.z;\n  float c = Circle( pos.xy, radius * z / height );\n  float h = abs(z) - height;\n  return max( c, h );\n}\n\nfloat Pyramid( vec3 pos, vec3 size ) {\n  float y = ( size.y ) - pos.y;\n  float c = Square( pos.xz, size.xz * ( y / ( size.y * 2.0) ) );\n  float h = abs(y) - size.y * 2.0;\n  return max( c, h );\n}\n\nfloat Pyramid( vec3 pos, float size ) {\n  return Pyramid( pos, vec3( size ) );\n}\n\nfloat Sphere( vec3 pos, float radius ) {\n  return length( pos ) - radius;\n}\n\nfloat Box( vec3 pos, vec3 size ) {\n  vec3 result = abs( pos ) - size;\n  return min( max( result.x, max( result.y, result.z) ), 0.0 ) +\n       length( max(result, 0.0 ) );\n}\n\nfloat Box( vec3 pos, float size ) {\n  return Box( pos, vec3( size ) );\n}\n\nfloat Box( vec3 pos, vec3 size, float radius )\n{\n  vec3 result = abs( pos ) - size;\n  return length( max( result, 0.0 ) ) - radius;\n}\n\nfloat Box( vec3 pos, float size, float radius ) {\n  return Box( pos, vec3( size ), radius );\n}\n\nfloat Cylinder( vec3 pos, float radius, float height ) {\n  float c = Circle( pos.xy, radius );\n  float h = abs( pos.z ) - height;\n  return max(c, h);\n}\n\nfloat Capsule( vec3 pos, vec3 a, vec3 b, float r ) {\n    return Line( pos, a, b ) - r;\n}\n\nfloat Torus( vec3 pos, vec2 size ) {\n  vec2 c2 = vec2( length( pos.xy ) - size.x, pos.z );\n  return length( c2 ) - size.y;\n}\n\nfloat Octahedron( vec3 pos, float size ) {\n  float hs = size;\n  float result = Box( pos, size );\n  result = max( result, -Plane( pos, vec3( 1, 1, 1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1, 1, 1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( 1, -1, 1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1, -1, 1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( 1, 1, -1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1, 1, -1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( 1, -1, -1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1, -1, -1 ), hs ) );\n  return result;\n}\n\nfloat Dodecahedron( vec3 pos, float size ) {\n    float hs = PHI_P * size;\n    float result = Box( pos, size );\n    result = max( result, -Plane( pos, vec3( 0, PHI_P, 1  ), hs ) );\n    result = max( result, -Plane( pos, vec3( 0, -PHI_P, 1 ), hs ) );\n    result = max( result, -Plane( pos, vec3( 0, PHI_P, -1 ), hs ) );\n    result = max( result, -Plane( pos, vec3( 0, -PHI_P, -1 ), hs ) );\n    result = max( result, -Plane( pos, vec3( 1, 0, PHI_P ), hs ) );\n    result = max( result, -Plane( pos, vec3( -1, 0, PHI_P ), hs ) );\n    result = max( result, -Plane( pos, vec3( 1, 0, -PHI_P ), hs ) );\n    result = max( result, -Plane( pos, vec3( -1, 0, -PHI_P ), hs ) );\n    result = max( result, -Plane( pos, vec3( PHI_P, 1, 0 ), hs ) );\n    result = max( result, -Plane( pos, vec3( -PHI_P, 1, 0 ), hs ) );\n    result = max( result, -Plane( pos, vec3( PHI_P, -1, 0 ), hs ) );\n    result = max( result, -Plane( pos, vec3( -PHI_P, -1, 0 ), hs ) );\n    return result;\n}\n\nfloat Icosahedron( vec3 pos, float size ) {\n  float hs = PHI_P * size;\n  float result = Box( pos, size );\n  result = max( result, -Plane( pos, vec3( 1, 1, 1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1, 1, 1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( 1, -1, 1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1, -1, 1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( 1, 1, -1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1,1, -1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( 1,-1, -1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1,-1, -1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( 0, PHI_N, PHI_P ), hs ) );\n  result = max( result, -Plane( pos, vec3( 0, PHI_N,- PHI_P ), hs ) );\n  result = max( result, -Plane( pos, vec3( 0, -PHI_N, PHI_P ), hs ) );\n  result = max( result, -Plane( pos, vec3( 0, -PHI_N,- PHI_P ), hs ) );\n  result = max( result, -Plane( pos, vec3( PHI_P, 0, PHI_N ), hs ) );\n  result = max( result, -Plane( pos, vec3( PHI_P, 0, -PHI_N ), hs ) );\n  result = max( result, -Plane( pos, vec3( -PHI_P, 0, PHI_N ), hs ) );\n  result = max( result, -Plane( pos, vec3( -PHI_P, 0, -PHI_N ), hs ) );\n  result = max( result, -Plane( pos, vec3( PHI_N, PHI_P, 0 ), hs ) );\n  result = max( result, -Plane( pos, vec3( PHI_N, -PHI_P, 0 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -PHI_N, PHI_P, 0 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -PHI_N, -PHI_P, 0 ), hs ) );\n  return result;\n}\n\nfloat Hexagon( vec3 pos, vec2 size ) {\n  vec3 apos = abs( pos );\n  float z = apos.z - size.y;\n  float xy = max( apos.x * 0.8660254038 + apos.y * 0.5, apos.y ) - size.x;\n  return max( xy, z );\n}\n\nfloat Tetrahedron( vec3 pos, float size ) {\n  float hs = size;\n  float result = Box( pos, size );\n  result = max( result, -Plane( pos, vec3( 1, 1, 1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( 1, -1, -1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1, 1, -1 ), hs ) );\n  result = max( result, -Plane( pos, vec3( -1, -1, 1 ), hs ) );\n  return result;\n}\n"},function(e,t){e.exports="#define GLSLIFY 1\nfloat Shell( float a, float d ) {\n  float d2 = d * 0.5;\n  return max( a - d2, -d2 - a );\n}\n\nfloat Morph( float a, float b, float d ) {\n    return d * a + ( 1.0 - d ) * b;\n}\n\nfloat Blend( float a, float b, float r ) {\n    return min( min ( a, b ), sqrt(a) + sqrt(b) - r );\n}\n\nfloat Union( float a, float b) {\n  return min( a, b);\n}\n\nfloat UnionStep( float a, float b, float r ) {\n  float am = a - r;\n  float bm = b - r;\n  float m = max( am, bm );\n  return min(min( b , a ), m);\n}\n\nfloat UnionRound( float a, float b, float r ) {\n  vec2 u = max( vec2( r - a, r - b ), vec2( 0.0 ) );\n  return max( r, min( a, b ) ) - length(u);\n}\n\nfloat UnionSoft( float a, float b, float r ) {\n  float u = max( r - abs( a - b ), 0.0 );\n  return min( a, b )- u * u * 0.25 / r;\n}\n\nfloat Intersection( float a, float b ) {\n  return max( a, b );\n}\n\nfloat Difference( float a, float b ) {\n  return max( a, -b );\n}\n"},function(e,t,n){e.exports="precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\n"+n(0)+"\n"+n(1)+"\n"+n(11)+"\n\nuniform vec2 vUv;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / BOUNDS;\n\n  vec2 q = vUv;\n  vec2 p = 2.0 * q - 1.0;\n  p.x *= iAspect;\n\n  vec3 ro = iCameraEyePoint;\n  vec3 rd = normalize( vec3( p.xy, - tan( 2.5 * iCameraFov ) ) );\n  rd *= mat3(iCameraViewMatrix);\n  rd *= iDevicePixelRatio;\n  ro *= iDevicePixelRatio;\n\n  float t = castRay( ro, rd );\n  vec3 pos = ro + t * rd;\n  vec3 normal = calcNormal( pos );\n\n  //Round texture coordinates to assign values into pixels\n  //floor(value + 0.5) = round(value)\n  float x = float( floor( uv.x + 0.5 ) );\n  float y = float( floor( uv.y + 0.5 ) );\n\n  //Uses texture coordinates to assign float values (2 by 2 texture used)\n  //0 pixel (RGBA) => normal.x\n  //1 pixel (RGBA) => normal.y\n  //2 pixel (RGBA) => normal.z\n  //3 pixel (RGBA) => ray flight time\n\n  //Use mixes instead of if statement for performance\n  float result = mix( normal.x, normal.y, x );\n  result = mix( result, mix( normal.z, t, x ), y );\n\n  //encode the float into the r, g, b, a channels\n  gl_FragColor = encode_float(result);\n}\n"},function(e,t){e.exports="#define GLSLIFY 1\nfloat shift_right (float v, float amt) {\n    v = floor(v) + 0.5;\n    return floor(v / exp2(amt));\n}\nfloat shift_left (float v, float amt) {\n    return floor(v * exp2(amt) + 0.5);\n}\nfloat mask_last (float v, float bits) {\n    return mod(v, shift_left(1.0, bits));\n}\nfloat extract_bits (float num, float from, float to) {\n    from = floor(from + 0.5); to = floor(to + 0.5);\n    return mask_last(shift_right(num, from), to - from);\n}\nvec4 encode_float (float val) {\n    if (val == 0.0) return vec4(0, 0, 0, 0);\n    float sign = val > 0.0 ? 0.0 : 1.0;\n    val = abs(val);\n    float exponent = floor(log2(val));\n    float biased_exponent = exponent + 127.0;\n    float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;\n    float t = biased_exponent / 2.0;\n    float last_bit_of_biased_exponent = fract(t) * 2.0;\n    float remaining_bits_of_biased_exponent = floor(t);\n    float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;\n    float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;\n    float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;\n    float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\n    return vec4(byte4, byte3, byte2, byte1);\n}\n"},function(e,t,n){"use strict";var a=1e3;if(!navigator.getVRDisplays){var r=function(){return this.hasPosition=!1,this.hasOrientation=!1,this.hasExternalDisplay=!1,this.canPresent=!1,this.maxLayers=0,this.hasPassThroughCamera=!1,this},o=function(){return this.position=new Float32Array(3),this.orientation=new Float32Array(4),this.linearVelocity=null,this.linearAcceleration=null,this.angularVelocity=null,this.angularAcceleration=null,this},i=function(){return this.timestamp=null,this.leftProjectionMatrix=new Float32Array(16),this.leftViewMatrix=new Float32Array(16),this.rightProjectionMatrix=new Float32Array(16),this.rightViewMatrix=new Float32Array(16),this.pose=null,this},s=function(){return this.modelMatrix=new Float32Array(16),this},l=new function(){var e=null;this.isConnected=!1,this.isPresenting=!1,this.capabilities=new r,this.capabilities.hasOrientation=!0,this.capabilities.canPresent=!0,this.capabilities.maxLayers=1,this.capabilities.hasPosition=!0,this.capabilities.hasPassThroughCamera=!0,this.getEyeParameters=function(e){return null},this.displayId=a++,this.displayName="ARKit VR Device",this.getFrameData=function(e){e.timestamp=performance.now(),e.pose=this.getPose(),e.leftProjectionMatrix=e.rightProjectionMatrix=this.projectionMatrix_,e.leftViewMatrix=e.rightViewMatrix=this.viewMatrix_},this.pose_=new o,this.getPose=function(){return this.pose_},this.projectionMatrix_=new Float32Array(16),this.viewMatrix_=new Float32Array(16),this.resetPose=function(){};var t=.01;Object.defineProperty(this,"depthNear",{get:function(){return t},set:function(e){t=e}});var n=1e4;return Object.defineProperty(this,"depthFar",{get:function(){return n},set:function(e){n=e}}),this.requestAnimationFrame=function(e){return window.requestAnimationFrame(e)},this.cancelAnimationFrame=function(e){return window.cancelAnimationFrame(e)},this.requestPresent=function(t){var n=this;return new Promise(function(a,r){n.isPresenting=!0,e=t,a()})},this.exitPresent=function(){var e=this;return new Promise(function(t,n){e.isPresenting=!1,t()})},this.getLayers=function(){return e},this.submitFrame=function(e){},this.hitTest=function(){},this.getPlanes=function(){return this.anchors_},this};navigator.getVRDisplays=function(){return null!=window.getVRDisplaysPromise?window.getVRDisplaysPromise:(window.getVRDisplaysPromise=new Promise(function(e,t){e([l])}),window.getVRDisplaysPromise)},window.VRHit=s,window.VRFrameData=i}}])});
//# sourceMappingURL=webar-desktop.min.js.map